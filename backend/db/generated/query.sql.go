// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPersonToTransaction = `-- name: AddPersonToTransaction :one
UPDATE transactions
SET assigned_to = array_append(COALESCE(assigned_to, '{}'), $2), updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, description, amount, assigned_to, date_uploaded, file_name,
          transaction_date, posted_date, card_number, category_id,
          created_at, updated_at
`

type AddPersonToTransactionParams struct {
	ID          pgtype.UUID `json:"id"`
	ArrayAppend interface{} `json:"array_append"`
}

func (q *Queries) AddPersonToTransaction(ctx context.Context, arg AddPersonToTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, addPersonToTransaction, arg.ID, arg.ArrayAppend)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AssignedTo,
		&i.DateUploaded,
		&i.FileName,
		&i.TransactionDate,
		&i.PostedDate,
		&i.CardNumber,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, description, color)
VALUES ($1, $2, $3)
RETURNING id, name, description, color, created_at, updated_at
`

type CreateCategoryParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Color       pgtype.Text `json:"color"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.Name, arg.Description, arg.Color)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPerson = `-- name: CreatePerson :one
INSERT INTO people (name, email)
VALUES ($1, $2)
RETURNING id, name, email, created_at, updated_at
`

type CreatePersonParams struct {
	Name  string      `json:"name"`
	Email pgtype.Text `json:"email"`
}

func (q *Queries) CreatePerson(ctx context.Context, arg CreatePersonParams) (Person, error) {
	row := q.db.QueryRow(ctx, createPerson, arg.Name, arg.Email)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (description, amount, file_name, transaction_date, posted_date, card_number, category_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, description, amount, assigned_to, date_uploaded, file_name,
          transaction_date, posted_date, card_number, category_id,
          created_at, updated_at
`

type CreateTransactionParams struct {
	Description     string         `json:"description"`
	Amount          pgtype.Numeric `json:"amount"`
	FileName        pgtype.Text    `json:"file_name"`
	TransactionDate pgtype.Date    `json:"transaction_date"`
	PostedDate      pgtype.Date    `json:"posted_date"`
	CardNumber      pgtype.Text    `json:"card_number"`
	CategoryID      pgtype.UUID    `json:"category_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.Description,
		arg.Amount,
		arg.FileName,
		arg.TransactionDate,
		arg.PostedDate,
		arg.CardNumber,
		arg.CategoryID,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AssignedTo,
		&i.DateUploaded,
		&i.FileName,
		&i.TransactionDate,
		&i.PostedDate,
		&i.CardNumber,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllTransactions = `-- name: DeleteAllTransactions :exec
DELETE FROM transactions
`

func (q *Queries) DeleteAllTransactions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllTransactions)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories
WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const deletePerson = `-- name: DeletePerson :exec
DELETE FROM people
WHERE id = $1
`

func (q *Queries) DeletePerson(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePerson, id)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions
WHERE id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTransaction, id)
	return err
}

const getCategories = `-- name: GetCategories :many
SELECT id, name, description, color, created_at, updated_at
FROM categories
ORDER BY name
`

// Categories queries
func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Color,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, description, color, created_at, updated_at
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id pgtype.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryByName = `-- name: GetCategoryByName :one
SELECT id, name, description, color, created_at, updated_at
FROM categories
WHERE name = $1
`

func (q *Queries) GetCategoryByName(ctx context.Context, name string) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByName, name)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPeople = `-- name: GetPeople :many
SELECT id, name, email, created_at, updated_at
FROM people
ORDER BY created_at
`

// People queries
func (q *Queries) GetPeople(ctx context.Context) ([]Person, error) {
	rows, err := q.db.Query(ctx, getPeople)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Person
	for rows.Next() {
		var i Person
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonByID = `-- name: GetPersonByID :one
SELECT id, name, email, created_at, updated_at
FROM people
WHERE id = $1
`

func (q *Queries) GetPersonByID(ctx context.Context, id pgtype.UUID) (Person, error) {
	row := q.db.QueryRow(ctx, getPersonByID, id)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPersonByName = `-- name: GetPersonByName :one
SELECT id, name, email, created_at, updated_at
FROM people
WHERE name = $1
`

func (q *Queries) GetPersonByName(ctx context.Context, name string) (Person, error) {
	row := q.db.QueryRow(ctx, getPersonByName, name)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalsByAssignedTo = `-- name: GetTotalsByAssignedTo :many
SELECT p.name as assigned_to, SUM(t.amount / array_length(t.assigned_to, 1))::numeric as total
FROM transactions t
CROSS JOIN LATERAL unnest(t.assigned_to) AS person_id
JOIN people p ON p.id = person_id
WHERE t.assigned_to IS NOT NULL AND array_length(t.assigned_to, 1) > 0
GROUP BY p.id, p.name
ORDER BY p.name
`

type GetTotalsByAssignedToRow struct {
	AssignedTo string         `json:"assigned_to"`
	Total      pgtype.Numeric `json:"total"`
}

func (q *Queries) GetTotalsByAssignedTo(ctx context.Context) ([]GetTotalsByAssignedToRow, error) {
	rows, err := q.db.Query(ctx, getTotalsByAssignedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalsByAssignedToRow
	for rows.Next() {
		var i GetTotalsByAssignedToRow
		if err := rows.Scan(&i.AssignedTo, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalsByCategory = `-- name: GetTotalsByCategory :many
SELECT c.name as category_name, SUM(t.amount)::numeric as total
FROM transactions t
JOIN categories c ON t.category_id = c.id
WHERE t.category_id IS NOT NULL
GROUP BY c.id, c.name
ORDER BY c.name
`

type GetTotalsByCategoryRow struct {
	CategoryName string         `json:"category_name"`
	Total        pgtype.Numeric `json:"total"`
}

func (q *Queries) GetTotalsByCategory(ctx context.Context) ([]GetTotalsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getTotalsByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTotalsByCategoryRow
	for rows.Next() {
		var i GetTotalsByCategoryRow
		if err := rows.Scan(&i.CategoryName, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, description, amount, assigned_to, date_uploaded, file_name,
       transaction_date, posted_date, card_number, category_id,
       created_at, updated_at
FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id pgtype.UUID) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AssignedTo,
		&i.DateUploaded,
		&i.FileName,
		&i.TransactionDate,
		&i.PostedDate,
		&i.CardNumber,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT id, description, amount, assigned_to, date_uploaded, file_name,
       transaction_date, posted_date, card_number, category_id,
       created_at, updated_at
FROM transactions
ORDER BY date_uploaded DESC
`

// Transactions queries
func (q *Queries) GetTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Amount,
			&i.AssignedTo,
			&i.DateUploaded,
			&i.FileName,
			&i.TransactionDate,
			&i.PostedDate,
			&i.CardNumber,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByAssignedTo = `-- name: GetTransactionsByAssignedTo :many
SELECT id, description, amount, assigned_to, date_uploaded, file_name,
       transaction_date, posted_date, card_number, category_id,
       created_at, updated_at
FROM transactions
WHERE $1 = ANY(assigned_to)
ORDER BY date_uploaded DESC
`

func (q *Queries) GetTransactionsByAssignedTo(ctx context.Context, assignedTo []pgtype.UUID) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByAssignedTo, assignedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Amount,
			&i.AssignedTo,
			&i.DateUploaded,
			&i.FileName,
			&i.TransactionDate,
			&i.PostedDate,
			&i.CardNumber,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByFileName = `-- name: GetTransactionsByFileName :many
SELECT id, description, amount, assigned_to, date_uploaded, file_name,
       transaction_date, posted_date, card_number, category_id,
       created_at, updated_at
FROM transactions
WHERE file_name = $1
ORDER BY date_uploaded DESC
`

func (q *Queries) GetTransactionsByFileName(ctx context.Context, fileName pgtype.Text) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByFileName, fileName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Amount,
			&i.AssignedTo,
			&i.DateUploaded,
			&i.FileName,
			&i.TransactionDate,
			&i.PostedDate,
			&i.CardNumber,
			&i.CategoryID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePersonFromTransaction = `-- name: RemovePersonFromTransaction :one
UPDATE transactions
SET assigned_to = array_remove(assigned_to, $2), updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, description, amount, assigned_to, date_uploaded, file_name,
          transaction_date, posted_date, card_number, category_id,
          created_at, updated_at
`

type RemovePersonFromTransactionParams struct {
	ID          pgtype.UUID `json:"id"`
	ArrayRemove interface{} `json:"array_remove"`
}

func (q *Queries) RemovePersonFromTransaction(ctx context.Context, arg RemovePersonFromTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, removePersonFromTransaction, arg.ID, arg.ArrayRemove)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AssignedTo,
		&i.DateUploaded,
		&i.FileName,
		&i.TransactionDate,
		&i.PostedDate,
		&i.CardNumber,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const unassignTransactionsByPerson = `-- name: UnassignTransactionsByPerson :exec
UPDATE transactions
SET assigned_to = array_remove(assigned_to, $1), updated_at = CURRENT_TIMESTAMP
WHERE $1 = ANY(assigned_to)
`

func (q *Queries) UnassignTransactionsByPerson(ctx context.Context, arrayRemove interface{}) error {
	_, err := q.db.Exec(ctx, unassignTransactionsByPerson, arrayRemove)
	return err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET name = $2, description = $3, color = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, description, color, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Color       pgtype.Text `json:"color"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Color,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Color,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePerson = `-- name: UpdatePerson :one
UPDATE people
SET name = $2, email = $3, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, email, created_at, updated_at
`

type UpdatePersonParams struct {
	ID    pgtype.UUID `json:"id"`
	Name  string      `json:"name"`
	Email pgtype.Text `json:"email"`
}

func (q *Queries) UpdatePerson(ctx context.Context, arg UpdatePersonParams) (Person, error) {
	row := q.db.QueryRow(ctx, updatePerson, arg.ID, arg.Name, arg.Email)
	var i Person
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTransactionAssignment = `-- name: UpdateTransactionAssignment :one
UPDATE transactions
SET assigned_to = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, description, amount, assigned_to, date_uploaded, file_name,
          transaction_date, posted_date, card_number, category_id,
          created_at, updated_at
`

type UpdateTransactionAssignmentParams struct {
	ID         pgtype.UUID   `json:"id"`
	AssignedTo []pgtype.UUID `json:"assigned_to"`
}

func (q *Queries) UpdateTransactionAssignment(ctx context.Context, arg UpdateTransactionAssignmentParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionAssignment, arg.ID, arg.AssignedTo)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AssignedTo,
		&i.DateUploaded,
		&i.FileName,
		&i.TransactionDate,
		&i.PostedDate,
		&i.CardNumber,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTransactionCategory = `-- name: UpdateTransactionCategory :one
UPDATE transactions
SET category_id = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, description, amount, assigned_to, date_uploaded, file_name,
          transaction_date, posted_date, card_number, category_id,
          created_at, updated_at
`

type UpdateTransactionCategoryParams struct {
	ID         pgtype.UUID `json:"id"`
	CategoryID pgtype.UUID `json:"category_id"`
}

func (q *Queries) UpdateTransactionCategory(ctx context.Context, arg UpdateTransactionCategoryParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionCategory, arg.ID, arg.CategoryID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Amount,
		&i.AssignedTo,
		&i.DateUploaded,
		&i.FileName,
		&i.TransactionDate,
		&i.PostedDate,
		&i.CardNumber,
		&i.CategoryID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
